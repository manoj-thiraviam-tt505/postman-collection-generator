/**
 * Common declaration file to define 'zcode' module for extensions implementation.
 */
declare module 'zcode' {
    export type ProviderResult<T> = T | undefined | PromiseLike<T | undefined>;
    export class Disposable {
        constructor(func: () => void);
        dispose(): void;
        static create(func: () => void): Disposable;
        static from(...disposableLikes: { dispose: () => any }[]): Disposable;
        constructor(callOnDispose: Function);
    }
    export interface CancellationToken {
        readonly isCancellationRequested: boolean;
        readonly onCancellationRequested: Event<any>;
    }
    export interface Event<T> {
        (listener: (e: T) => any, thisArgs?: any, disposables?: Disposable[]): Disposable;
    }
    export class EventEmitter<T> {
        event: Event<T>;
        fire(data?: T): void;
        dispose(): void;
    }
    export class Uri {
        static file(path: string): Uri;
        static parse(value: string): Uri;
        private constructor(scheme: string, authority: string, path: string, query: string, fragment: string);
        readonly scheme: string;
        readonly authority: string;
        readonly path: string;
        readonly query: string;
        readonly fragment: string;
        readonly fsPath: string;
        with(change: { scheme?: string; authority?: string; path?: string; query?: string; fragment?: string }): Uri;
        toString(skipEncoding?: boolean): string;
        toJSON(): any;
    }
    export interface TextLine {
        /**
         * The zero-based line number.
         */
        readonly lineNumber: number;

        /**
         * The text of this line without the line separator characters.
         */
        readonly text: string;

        /**
         * The range this line covers without the line separator characters.
         */
        readonly range: Range;

        /**
         * The range this line covers with the line separator characters.
         */
        readonly rangeIncludingLineBreak: Range;

        /**
         * The offset of the first character which is not a whitespace character as defined
         * by `/\s/`. **Note** that if a line is all whitespaces the length of the line is returned.
         */
        readonly firstNonWhitespaceCharacterIndex: number;

        /**
         * Whether this line is whitespace only, shorthand
         * for [TextLine.firstNonWhitespaceCharacterIndex](#TextLine.firstNonWhitespaceCharacterIndex) === [TextLine.text.length](#TextLine.text).
         */
        readonly isEmptyOrWhitespace: boolean;
    }
    /**
     * Represents an end of line character sequence in a [document](#TextDocument).
     */
    export enum EndOfLine {
        /**
         * The line feed `\n` character.
         */
        LF = 1,
        /**
         * The carriage return line feed `\r\n` sequence.
         */
        CRLF = 2
    }
    export class MarkdownString {

        /**
         * The markdown string.
         */
        value: string;

        /**
         * Indicates that this markdown string is from a trusted source. Only *trusted*
         * markdown supports links that execute commands, e.g. `[Run it](command:myCommandId)`.
         */
        isTrusted?: boolean;

        /**
         * Creates a new markdown string with the given value.
         *
         * @param value Optional, initial value.
         */
        constructor(value?: string);

        /**
         * Appends and escapes the given string to this markdown string.
         * @param value Plain text.
         */
        appendText(value: string): MarkdownString;

        /**
         * Appends the given string 'as is' to this markdown string.
         * @param value Markdown string.
         */
        appendMarkdown(value: string): MarkdownString;

        /**
         * Appends the given string as codeblock using the provided language.
         * @param value A code snippet.
         * @param language An optional [language identifier](#languages.getLanguages).
         */
        appendCodeblock(value: string, language?: string): MarkdownString;
    }
    export type MarkedString = MarkdownString | string | { language: string; value: string }; // keep for compatibility reason
    export class RelativePattern {
        base: string;
        pattern: string;
        constructor(base: WorkspaceFolder | string, pattern: string)
    }
    export type GlobPattern = string | RelativePattern;
    export interface DocumentFilter {
        language?: string;
        scheme?: string;
        pattern?: GlobPattern;
    }
    export type DocumentSelector = DocumentFilter | string | Array<DocumentFilter | string>;

    export enum OverviewRulerLane {
        Left = 1,
        Center = 2,
        Right = 4,
        Full = 7
    }

    export class ThemeColor {
        /**
         * Creates a reference to a theme color.
         */
        constructor(id: string);
    }

    export interface ThemableDecorationAttachmentRenderOptions {
        /**
         * Defines a text content that is shown in the attachment. Either an icon or a text can be shown, but not both.
         */
        content?: string;
        /**
         * An **absolute path** or an URI to an image to be rendered in the attachment. Either an icon
         * or a text can be shown, but not both.
         */
        contentIconPath?: string | Uri;
        /**
         * CSS styling property that will be applied to the decoration attachment.
         */
        border?: string;
        /**
         * CSS styling property that will be applied to text enclosed by a decoration.
         */
        borderColor?: string | ThemeColor;
        /**
         * CSS styling property that will be applied to the decoration attachment.
         */
        fontStyle?: string;
        /**
         * CSS styling property that will be applied to the decoration attachment.
         */
        fontWeight?: string;
        /**
         * CSS styling property that will be applied to the decoration attachment.
         */
        textDecoration?: string;
        /**
         * CSS styling property that will be applied to the decoration attachment.
         */
        color?: string | ThemeColor;
        /**
         * CSS styling property that will be applied to the decoration attachment.
         */
        backgroundColor?: string | ThemeColor;
        /**
         * CSS styling property that will be applied to the decoration attachment.
         */
        margin?: string;
        /**
         * CSS styling property that will be applied to the decoration attachment.
         */
        width?: string;
        /**
         * CSS styling property that will be applied to the decoration attachment.
         */
        height?: string;
    }

    /**
     * Represents theme specific rendering styles for a [text editor decoration](#TextEditorDecorationType).
     */
    export interface ThemableDecorationRenderOptions {
        /**
         * Background color of the decoration. Use rgba() and define transparent background colors to play well with other decorations.
         * Alternatively a color from the color registry can be [referenced](#ThemeColor).
         */
        backgroundColor?: string | ThemeColor;

        /**
         * CSS styling property that will be applied to text enclosed by a decoration.
         */
        outline?: string;

        /**
         * CSS styling property that will be applied to text enclosed by a decoration.
         * Better use 'outline' for setting one or more of the individual outline properties.
         */
        outlineColor?: string | ThemeColor;

        /**
         * CSS styling property that will be applied to text enclosed by a decoration.
         * Better use 'outline' for setting one or more of the individual outline properties.
         */
        outlineStyle?: string;

        /**
         * CSS styling property that will be applied to text enclosed by a decoration.
         * Better use 'outline' for setting one or more of the individual outline properties.
         */
        outlineWidth?: string;

        /**
         * CSS styling property that will be applied to text enclosed by a decoration.
         */
        border?: string;

        /**
         * CSS styling property that will be applied to text enclosed by a decoration.
         * Better use 'border' for setting one or more of the individual border properties.
         */
        borderColor?: string | ThemeColor;

        /**
         * CSS styling property that will be applied to text enclosed by a decoration.
         * Better use 'border' for setting one or more of the individual border properties.
         */
        borderRadius?: string;

        /**
         * CSS styling property that will be applied to text enclosed by a decoration.
         * Better use 'border' for setting one or more of the individual border properties.
         */
        borderSpacing?: string;

        /**
         * CSS styling property that will be applied to text enclosed by a decoration.
         * Better use 'border' for setting one or more of the individual border properties.
         */
        borderStyle?: string;

        /**
         * CSS styling property that will be applied to text enclosed by a decoration.
         * Better use 'border' for setting one or more of the individual border properties.
         */
        borderWidth?: string;

        /**
         * CSS styling property that will be applied to text enclosed by a decoration.
         */
        fontStyle?: string;

        /**
         * CSS styling property that will be applied to text enclosed by a decoration.
         */
        fontWeight?: string;

        /**
         * CSS styling property that will be applied to text enclosed by a decoration.
         */
        textDecoration?: string;

        /**
         * CSS styling property that will be applied to text enclosed by a decoration.
         */
        cursor?: string;

        /**
         * CSS styling property that will be applied to text enclosed by a decoration.
         */
        color?: string | ThemeColor;

        /**
         * CSS styling property that will be applied to text enclosed by a decoration.
         */
        opacity?: string;

        /**
         * CSS styling property that will be applied to text enclosed by a decoration.
         */
        letterSpacing?: string;

        /**
         * An **absolute path** or an URI to an image to be rendered in the gutter.
         */
        gutterIconPath?: string | Uri;

        /**
         * Specifies the size of the gutter icon.
         * Available values are 'auto', 'contain', 'cover' and any percentage value.
         * For further information: https://msdn.microsoft.com/en-us/library/jj127316(v=vs.85).aspx
         */
        gutterIconSize?: string;

        /**
         * The color of the decoration in the overview ruler. Use rgba() and define transparent colors to play well with other decorations.
         */
        overviewRulerColor?: string | ThemeColor;

        /**
         * Defines the rendering options of the attachment that is inserted before the decorated text
         */
        before?: ThemableDecorationAttachmentRenderOptions;

        /**
         * Defines the rendering options of the attachment that is inserted after the decorated text
         */
        after?: ThemableDecorationAttachmentRenderOptions;
    }

    /**
     * Describes the behavior of decorations when typing/editing at their edges.
     */
    export enum DecorationRangeBehavior {
        /**
         * The decoration's range will widen when edits occur at the start or end.
         */
        OpenOpen = 0,
        /**
         * The decoration's range will not widen when edits occur at the start of end.
         */
        ClosedClosed = 1,
        /**
         * The decoration's range will widen when edits occur at the start, but not at the end.
         */
        OpenClosed = 2,
        /**
         * The decoration's range will widen when edits occur at the end, but not at the start.
         */
        ClosedOpen = 3
    }

    /**
     * Represents rendering styles for a [text editor decoration](#TextEditorDecorationType).
     */
    export interface DecorationRenderOptions extends ThemableDecorationRenderOptions {
        /**
         * Should the decoration be rendered also on the whitespace after the line text.
         * Defaults to `false`.
         */
        isWholeLine?: boolean;

        /**
         * Customize the growing behavior of the decoration when edits occur at the edges of the decoration's range.
         * Defaults to `DecorationRangeBehavior.OpenOpen`.
         */
        rangeBehavior?: DecorationRangeBehavior;

        /**
         * The position in the overview ruler where the decoration should be rendered.
         */
        overviewRulerLane?: OverviewRulerLane;

        /**
         * Overwrite options for light themes.
         */
        light?: ThemableDecorationRenderOptions;

        /**
         * Overwrite options for dark themes.
         */
        dark?: ThemableDecorationRenderOptions;
    }

    export interface ThemableDecorationInstanceRenderOptions {
        /**
         * Defines the rendering options of the attachment that is inserted before the decorated text
         */
        before?: ThemableDecorationAttachmentRenderOptions;

        /**
         * Defines the rendering options of the attachment that is inserted after the decorated text
         */
        after?: ThemableDecorationAttachmentRenderOptions;
    }

    export interface DecorationInstanceRenderOptions extends ThemableDecorationInstanceRenderOptions {
        /**
         * Overwrite options for light themes.
         */
        light?: ThemableDecorationInstanceRenderOptions;

        /**
         * Overwrite options for dark themes.
         */
        dark?: ThemableDecorationInstanceRenderOptions;
    }

    /**
     * Represents options for a specific decoration in a [decoration set](#TextEditorDecorationType).
     */
    export interface DecorationOptions {

        /**
         * Range to which this decoration is applied. The range must not be empty.
         */
        range: Range;

        /**
         * A message that should be rendered when hovering over the decoration.
         */
        hoverMessage?: MarkedString | MarkedString[];

        /**
         * Render options applied to the current decoration. For performance reasons, keep the
         * number of decoration specific options small, and use decoration types wherever possible.
         */
        options?: DecorationInstanceRenderOptions;
    }

    export enum ViewColumn {
        Active = -1,
        Beside = -2,
        /**
         * The first editor column.
         */
        One = 1,
        /**
         * The second editor column.
         */
        Two = 2,
        /**
         * The third editor column.
         */
        Three = 3
    }

    /**
     * Rendering style of the cursor.
     */
    export enum TextEditorCursorStyle {
        /**
         * Render the cursor as a vertical thick line.
         */
        Line = 1,
        /**
         * Render the cursor as a block filled.
         */
        Block = 2,
        /**
         * Render the cursor as a thick horizontal line.
         */
        Underline = 3,
        /**
         * Render the cursor as a vertical thin line.
         */
        LineThin = 4,
        /**
         * Render the cursor as a block outlined.
         */
        BlockOutline = 5,
        /**
         * Render the cursor as a thin horizontal line.
         */
        UnderlineThin = 6
    }

    /**
     * Rendering style of the line numbers.
     */
    export enum TextEditorLineNumbersStyle {
        /**
         * Do not render the line numbers.
         */
        Off = 0,
        /**
         * Render the line numbers.
         */
        On = 1,
        /**
         * Render the line numbers with values relative to the primary cursor location.
         */
        Relative = 2
    }

    export interface TextEditorOptions {
        tabSize?: number | string;
        insertSpaces?: boolean | string;
        cursorStyle?: TextEditorCursorStyle;
        lineNumbers?: TextEditorLineNumbersStyle;
    }

    export interface TextEditor {
        readonly document: TextDocument;
        selection: Selection;
        selections: Selection[];
        readonly visibleRanges: Range[];
        options: TextEditorOptions;
        viewColumn?: ViewColumn;
        edit(callback: (editBuilder: TextEditorEdit) => void, options?: { undoStopBefore: boolean; undoStopAfter: boolean; }): PromiseLike<boolean>;
        insertSnippet(snippet: SnippetString, location?: Position | Range | Position[] | Range[], options?: { undoStopBefore: boolean; undoStopAfter: boolean; }): PromiseLike<boolean>;
        setDecorations(decorationType: TextEditorDecorationType, rangesOrOptions: Range[] | DecorationOptions[]): void;
        revealRange(range: Range, revealType?: TextEditorRevealType): void;
    }

    export interface TextEditorDecorationType {
        /**
         * Internal representation of the handle.
         */
        readonly key: string;
        /**
         * Remove this decoration type and all decorations on all text editors using it.
         */
        dispose(): void;
    }

    /**
     * Represents different [reveal](#TextEditor.revealRange) strategies in a text editor.
     */
    export enum TextEditorRevealType {
        /**
         * The range will be revealed with as little scrolling as possible.
         */
        Default = 0,
        /**
         * The range will always be revealed in the center of the viewport.
         */
        InCenter = 1,
        /**
         * If the range is outside the viewport, it will be revealed in the center of the viewport.
         * Otherwise, it will be revealed with as little scrolling as possible.
         */
        InCenterIfOutsideViewport = 2,
        /**
         * The range will always be revealed at the top of the viewport.
         */
        AtTop = 3
    }

    export interface TextEditorEdit {
        replace(location: Position | Range | Selection, value: string): void;
        insert(location: Position, value: string): void;
        delete(location: Range | Selection): void;
        setEndOfLine(endOfLine: EndOfLine): void;
    }

    export class TextEdit {

        /**
         * Utility to create a replace edit.
         *
         * @param range A range.
         * @param newText A string.
         * @return A new text edit object.
         */
        static replace(range: Range, newText: string): TextEdit;

        /**
         * Utility to create an insert edit.
         *
         * @param position A position, will become an empty range.
         * @param newText A string.
         * @return A new text edit object.
         */
        static insert(position: Position, newText: string): TextEdit;

        /**
         * Utility to create a delete edit.
         *
         * @param range A range.
         * @return A new text edit object.
         */
        static delete(range: Range): TextEdit;

        /**
         * Utility to create an eol-edit.
         *
         * @param eol An eol-sequence
         * @return A new text edit object.
         */
        static setEndOfLine(eol: EndOfLine): TextEdit;

        /**
         * The range this edit applies to.
         */
        range: Range;

        /**
         * The string this edit will insert.
         */
        newText: string;

        /**
         * The eol-sequence used in the document.
         *
         * *Note* that the eol-sequence will be applied to the
         * whole document.
         */
        newEol: EndOfLine;

        /**
         * Create a new TextEdit.
         *
         * @param range A range.
         * @param newText A string.
         */
        constructor(range: Range, newText: string);
    }

    /**
     * Represents sources that can cause `window.onDidChangeEditorSelection`
     */
    export enum TextEditorSelectionChangeKind {
        Keyboard = 1,
        Mouse = 2,
        Command = 3
    }

    /**
     * Represents an event describing the change in text editor selections.
     */
    export interface TextEditorSelectionChangeEvent {
        /**
         * The text editor for which the selections have changed.
         */
        textEditor: TextEditor;
        /**
         * The new text editor selections
         */
        selections: Selection[];
        kind?: TextEditorSelectionChangeKind;
    }

    export interface TextEditorOptionsChangeEvent {
        textEditor: TextEditor;
        options: TextEditorOptions;
    }

    export interface TextEditorVisibleRangesChangeEvent {
        /**
         * The text editor for which the visible ranges have changes.
         */
        textEditor: TextEditor;
        /**
         * The new text editor visible ranges.
         */
        visibleRanges: Range[];
    }

    /**
     * Represents an event describing the change of a text editor's view column.
     */
    export interface TextEditorViewColumnChangeEvent {
        /**
         * The text editor for which the options have changed.
         */
        textEditor: TextEditor;
        /**
         * The new value for the text editor's view column.
         */
        viewColumn: ViewColumn;
    }

    export enum CompletionTriggerKind {
        /**
         * Completion was triggered normally.
         */
        Invoke = 0,
        /**
         * Completion was triggered by a trigger character.
         */
        TriggerCharacter = 1,
        /**
         * Completion was re-triggered as current completion list is incomplete
         */
        TriggerForIncompleteCompletions = 2
    }
    /**
     * Completion item kinds.
     */
    export enum CompletionItemKind {
        Text = 0,
        Method = 1,
        Function = 2,
        Constructor = 3,
        Field = 4,
        Variable = 5,
        Class = 6,
        Interface = 7,
        Module = 8,
        Property = 9,
        Unit = 10,
        Value = 11,
        Enum = 12,
        Keyword = 13,
        Snippet = 14,
        Color = 15,
        Reference = 17,
        File = 16,
        Folder = 18,
        EnumMember = 19,
        Constant = 20,
        Struct = 21,
        Event = 22,
        Operator = 23,
        TypeParameter = 24
    }
    export interface CompletionContext {
        /**
         * How the completion was triggered.
         */
        readonly triggerKind: CompletionTriggerKind;

        /**
         * Character that triggered the completion item provider.
         *
         * `undefined` if provider was not triggered by a character.
         *
         * The trigger character is already in the document when the completion provider is triggered.
         */
        readonly triggerCharacter?: string;
    }

    /**
     * Represents a collection of [completion items](#CompletionItem) to be presented
     * in the editor.
     */
    export class CompletionList {

        /**
         * This list is not complete. Further typing should result in recomputing
         * this list.
         */
        isIncomplete?: boolean;

        /**
         * The completion items.
         */
        items: CompletionItem[];

        /**
         * Creates a new completion list.
         *
         * @param items The completion items.
         * @param isIncomplete The list is not complete.
         */
        constructor(items?: CompletionItem[], isIncomplete?: boolean);
    }

    export class CompletionItem {

        /**
         * The label of this completion item. By default
         * this is also the text that is inserted when selecting
         * this completion.
         */
        label: string;

        /**
         * The kind of this completion item. Based on the kind
         * an icon is chosen by the editor.
         */
        kind?: CompletionItemKind;

        /**
         * A human-readable string with additional information
         * about this item, like type or symbol information.
         */
        detail?: string;

        /**
         * A human-readable string that represents a doc-comment.
         */
        documentation?: string | MarkdownString;

        /**
         * A string that should be used when comparing this item
         * with other items. When `falsy` the [label](#CompletionItem.label)
         * is used.
         */
        sortText?: string;

        /**
         * A string that should be used when filtering a set of
         * completion items. When `falsy` the [label](#CompletionItem.label)
         * is used.
         */
        filterText?: string;

        /**
         * Select this item when showing. *Note* that only one completion item can be selected and
         * that the editor decides which item that is. The rule is that the *first* item of those
         * that match best is selected.
         */
        preselect?: boolean;

        /**
         * A string or snippet that should be inserted in a document when selecting
         * this completion. When `falsy` the [label](#CompletionItem.label)
         * is used.
         */
        insertText?: string | SnippetString;

        /**
         * A range of text that should be replaced by this completion item.
         *
         * Defaults to a range from the start of the [current word](#TextDocument.getWordRangeAtPosition) to the
         * current position.
         *
         * *Note:* The range must be a [single line](#Range.isSingleLine) and it must
         * [contain](#Range.contains) the position at which completion has been [requested](#CompletionItemProvider.provideCompletionItems).
         */
        range?: any;

        /**
         * An optional set of characters that when pressed while this completion is active will accept it first and
         * then type that character. *Note* that all commit characters should have `length=1` and that superfluous
         * characters will be ignored.
         */
        commitCharacters?: string[];

        /**
         * Keep whitespace of the [insertText](#CompletionItem.insertText) as is. By default, the editor adjusts leading
         * whitespace of new lines so that they match the indentation of the line for which the item is accepted - setting
         * this to `true` will prevent that.
         */
        keepWhitespace?: boolean;

        /**
         * An optional array of additional [text edits](#TextEdit) that are applied when
         * selecting this completion. Edits must not overlap with the main [edit](#CompletionItem.textEdit)
         * nor with themselves.
         */
        additionalTextEdits?: TextEdit[];

        /**
         * An optional [command](#Command) that is executed *after* inserting this completion. *Note* that
         * additional modifications to the current document should be described with the
         * [additionalTextEdits](#additionalTextEdits)-property.
         */
        command?: Command;

        /**
         * @deprecated Use `CompletionItem.insertText` and `CompletionItem.range` instead.
         *
         * ~~An [edit](#TextEdit) which is applied to a document when selecting
         * this completion. When an edit is provided the value of
         * [insertText](#CompletionItem.insertText) is ignored.~~
         *
         * ~~The [range](#Range) of the edit must be single-line and on the same
         * line completions were [requested](#CompletionItemProvider.provideCompletionItems) at.~~
         */
        textEdit?: TextEdit;

        /**
         * Creates a new completion item.
         *
         * Completion items must have at least a [label](#CompletionItem.label) which then
         * will be used as insert text as well as for sorting and filtering.
         *
         * @param label The label of the completion.
         * @param kind The [kind](#CompletionItemKind) of the completion.
         */
        constructor(label: string, kind?: CompletionItemKind);
    }

    /**
     * A snippet string is a template which allows to insert text
     * and to control the editor cursor when insertion happens.
     */
    export class SnippetString {

        /**
         * The snippet string.
         */
        value: string;

        constructor(value?: string);

        /**
         * Builder-function that appends the given string to
         * the [`value`](#SnippetString.value) of this snippet string.
         *
         * @param string A value to append 'as given'. The string will be escaped.
         * @return This snippet string.
         */
        appendText(string: string): SnippetString;

        /**
         * Builder-function that appends a tabstop (`$1`, `$2` etc) to
         * the [`value`](#SnippetString.value) of this snippet string.
         *
         * @param number The number of this tabstop, defaults to an auto-incremet
         * value starting at 1.
         * @return This snippet string.
         */
        appendTabstop(number?: number): SnippetString;

        /**
         * Builder-function that appends a placeholder (`${1:value}`) to
         * the [`value`](#SnippetString.value) of this snippet string.
         *
         * @param value The value of this placeholder - either a string or a function
         * with which a nested snippet can be created.
         * @param number The number of this tabstop, defaults to an auto-incremet
         * value starting at 1.
         * @return This snippet string.
         */
        appendPlaceholder(value: string | ((snippet: SnippetString) => any), number?: number): SnippetString;

        /**
         * Builder-function that appends a variable (`${VAR}`) to
         * the [`value`](#SnippetString.value) of this snippet string.
         *
         * @param name The name of the variable - excluding the `$`.
         * @param defaultValue The default value which is used when the variable name cannot
         * be resolved - either a string or a function with which a nested snippet can be created.
         * @return This snippet string.
         */
        appendVariable(name: string, defaultValue: string | ((snippet: SnippetString) => any)): SnippetString;
    }

    export interface DocumentSemanticTokensProvider {
        onDidChangeSemanticTokens?: Event<void>;
        provideDocumentSemanticTokens(document: TextDocument, token: CancellationToken): ProviderResult<SemanticTokens>;
        provideDocumentSemanticTokensEdits?(document: TextDocument, previousResultId: string, token: CancellationToken): ProviderResult<SemanticTokens | SemanticTokensEdits>;
    }

    export interface DocumentRangeSemanticTokensProvider {
        provideDocumentRangeSemanticTokens(document: TextDocument, range: Range, token: CancellationToken): ProviderResult<SemanticTokens>;
    }


    export class SemanticTokens {
        readonly resultId?: string;
        readonly data: Uint32Array;
        constructor(data: Uint32Array, resultId?: string);
    }

    export class SemanticTokensLegend {
        readonly tokenTypes: string[];
        readonly tokenModifiers: string[];
        constructor(tokenTypes: string[], tokenModifiers?: string[]);
    }

    export class SemanticTokensBuilder {
        constructor(legend?: SemanticTokensLegend);
        push(line: number, char: number, length: number, tokenType: number, tokenModifiers?: number): void;
        push(range: Range, tokenType: string, tokenModifiers?: string[]): void;
        build(resultId?: string): SemanticTokens;
    }

    export class SemanticTokensEdits {
        readonly resultId?: string;
        readonly edits: SemanticTokensEdit[];
        constructor(edits: SemanticTokensEdit[], resultId?: string);
    }

    export class SemanticTokensEdit {
        readonly start: number;
        readonly deleteCount: number;
        readonly data?: Uint32Array;
        constructor(start: number, deleteCount: number, data?: Uint32Array);
    }

    export interface CompletionItemProvider {
        provideCompletionItems(document: TextDocument,
            position: Position,
            token: CancellationToken | undefined,
            context: CompletionContext
        ): ProviderResult<CompletionItem[] | CompletionList>;
        resolveCompletionItem?(item: CompletionItem, token?: CancellationToken): ProviderResult<CompletionItem>;
    }

    export interface ReferenceContext {
        includeDeclaration: boolean;
    }

    export interface ReferenceProvider {
        provideReferences(document: TextDocument, position: Position, context: ReferenceContext, token: CancellationToken): ProviderResult<Location[]>;
    }

    export interface DocumentHighlightProvider {
        provideDocumentHighlights(document: TextDocument, position: Position, token: CancellationToken | undefined): ProviderResult<DocumentHighlight[]>;
    }

    export enum DocumentHighlightKind {
        Text = 0,
        Read = 1,
        Write = 2
    }

    export class DocumentHighlight {
        range: Range;
        kind?: DocumentHighlightKind;
        constructor(range: Range, kind?: DocumentHighlightKind);
    }

    /**
     * Represents the alignment of status bar items.
     */
    export enum StatusBarAlignment {
        /**
         * Aligned to the left side.
         */
        Left = 1,

        /**
         * Aligned to the right side.
         */
        Right = 2
    }

    /**
     * A status bar item is a status bar contribution that can
     * show text and icons and run a command on click.
     */
    export interface StatusBarItem {
        /**
         * The alignment of this item.
         */
        readonly alignment: StatusBarAlignment;
        /**
         * The priority of this item. Higher value means the item should
         * be shown more to the left.
         */
        readonly priority: number;
        /**
         * The text to show for the entry. To set a text with icon use the following pattern in text string:
         * $(fontawesomeClassName)
         */
        text: string;
        /**
         * The tooltip text when you hover over this entry.
         */
        tooltip: string | undefined;
        /**
         * The foreground color for this entry.
         */
        color: string | undefined;
        /**
         * The identifier of a command to run on click.
         */
        command: string | Command | undefined;
        /**
         * Shows the entry in the status bar.
         */
        show(): void;
        /**
         * Hide the entry in the status bar.
         */
        hide(): void;
        /**
         * Dispose and free associated resources. Hide the entry in the status bar.
         */
        dispose(): void;
    }

    /**
     * Represents a line and character position.
     */
    export class Position {
        /**
         * The zero-based line value.
         */
        readonly line: number;
        /**
         * The zero-based character value.
         */
        readonly character: number;
        constructor(line: number, character: number);
        /**
         * Check if this position is before `other`.
         *
         * @param other A position.
         * @return `true` if position is on a smaller line
         * or on the same line on a smaller character.
         */
        isBefore(other: Position): boolean;

        /**
         * Check if this position is before or equal to `other`.
         *
         * @param other A position.
         * @return `true` if position is on a smaller line
         * or on the same line on a smaller or equal character.
         */
        isBeforeOrEqual(other: Position): boolean;

        /**
         * Check if this position is after `other`.
         *
         * @param other A position.
         * @return `true` if position is on a greater line
         * or on the same line on a greater character.
         */
        isAfter(other: Position): boolean;

        /**
         * Check if this position is after or equal to `other`.
         *
         * @param other A position.
         * @return `true` if position is on a greater line
         * or on the same line on a greater or equal character.
         */
        isAfterOrEqual(other: Position): boolean;

        /**
         * Check if this position is equal to `other`.
         *
         * @param other A position.
         * @return `true` if the line and character of the given position are equal to
         * the line and character of this position.
         */
        isEqual(other: Position): boolean;

        /**
         * Compare this to `other`.
         *
         * @param other A position.
         * @return A number smaller than zero if this position is before the given position,
         * a number greater than zero if this position is after the given position, or zero when
         * this and the given position are equal.
         */
        compareTo(other: Position): number;

        /**
         * Create a new position relative to this position.
         *
         * @param lineDelta Delta value for the line value, default is `0`.
         * @param characterDelta Delta value for the character value, default is `0`.
         * @return A position which line and character is the sum of the current line and
         * character and the corresponding deltas.
         */
        translate(lineDelta?: number, characterDelta?: number): Position;

        /**
         * Derived a new position relative to this position.
         *
         * @param change An object that describes a delta to this position.
         * @return A position that reflects the given delta. Will return `this` position if the change
         * is not changing anything.
         */
        translate(change: { lineDelta?: number; characterDelta?: number; }): Position;

        /**
         * Create a new position derived from this position.
         *
         * @param line Value that should be used as line value, default is the [existing value](#Position.line)
         * @param character Value that should be used as character value, default is the [existing value](#Position.character)
         * @return A position where line and character are replaced by the given values.
         */
        with(line?: number, character?: number): Position;

        /**
         * Derived a new position from this position.
         *
         * @param change An object that describes a change to this position.
         * @return A position that reflects the given change. Will return `this` position if the change
         * is not changing anything.
         */
        with(change: { line?: number; character?: number; }): Position;
    }

    /**
     * Represents a location inside a resource, such as a line
     * inside a text file.
     */
    export class Location {

        /**
         * The resource identifier of this location.
         */
        uri: Uri;

        /**
         * The document range of this location.
         */
        range: Range;

        /**
         * Creates a new location object.
         *
         * @param uri The resource identifier.
         * @param rangeOrPosition The range or position. Positions will be converted to an empty range.
         */
        constructor(uri: Uri, rangeOrPosition: Range | Position);
    }

    /**
     * Pair of two positions.
     */
    export class Range {
        /**
         * Start position.
         */
        readonly start: Position;

        /**
         * End position.
         */
        readonly end: Position;

        /**
         * `true` if start and end are equal
         */
        isEmpty: boolean;

        /**
         * `true` if `start.line` and `end.line` are equal
         */
        isSingleLine: boolean;

        /**
         * Create a new range from two positions.
         * If `start` is not before or equal to `end`, the values will be swapped.
         *
         * @param start a position
         * @param end a position
         */
        constructor(start: Position, end: Position);

        /**
         * Create a new position from coordinates.
         *
         * @param startLine a zero based line value
         * @param startCharacter a zero based character value
         * @param endLine a zero based line value
         * @param endCharacter a zero based character value
         */
        constructor(startLine: number, startCharacter: number, endLine: number, endCharacter: number);

        /**
         * Check if a position or a range is in this range.
         *
         * @param positionOrRange a position or a range
         */
        contains(positionOrRange: Position | Range): boolean;

        /**
         * Check `other` equals this range.
         *
         * @param other a range
         */
        isEqual(other: Range): boolean;

        /**
         * Intersect `range` with this range and returns new range or `undefined`
         *
         * @param range a range
         */
        intersection(range: Range): Range | undefined;

        /**
         * Compute the union of `other` with this range.
         *
         * @param other a range
         */
        union(other: Range): Range;

        /**
         * Derived a new range from this range.
         *
         * @param start
         * @param end
         */
        with(start?: Position, end?: Position): Range;

        /**
         * Derived a new range from this range.
         */
        with(change: { start?: Position, end?: Position }): Range;
    }

    export class Selection extends Range {
        anchor: Position;
        active: Position;
        isReversed: boolean;
        constructor(anchor: Position, active: Position);
        constructor(anchorLine: number, anchorCharacter: number, activeLine: number, activeCharacter: number);
    }

    /**
     * The event that is fired when diagnostics change.
     */
    export interface DiagnosticChangeEvent {
        /**
         * An array of resources for which diagnostics have changed.
         */
        readonly uris: Uri[];
    }

    /**
     * Represents the severity of diagnostics.
     */
    export enum DiagnosticSeverity {

        /**
         * Something not allowed by the rules of a language or other means.
         */
        Error = 0,

        /**
         * Something suspicious but allowed.
         */
        Warning = 1,

        /**
         * Something to inform about but not a problem.
         */
        Information = 2,

        /**
         * Something to hint to a better way of doing it, like proposing
         * a refactoring.
         */
        Hint = 3
    }

    /**
     * Represents a related message and source code location for a diagnostic. This should be
     * used to point to code locations that cause or related to a diagnostics, e.g when duplicating
     * a symbol in a scope.
     */
    export class DiagnosticRelatedInformation {

        /**
         * The location of this related diagnostic information.
         */
        location: Location;

        /**
         * The message of this related diagnostic information.
         */
        message: string;

        /**
         * Creates a new related diagnostic information object.
         *
         * @param location The location.
         * @param message The message.
         */
        constructor(location: Location, message: string);
    }

    /**
     * Additional metadata about the type of a diagnostic.
     */
    export enum DiagnosticTag {
        /**
         * Unused or unnecessary code.
         *
         * Diagnostics with this tag are rendered faded out. The amount of fading
         * is controlled by the `"editorUnnecessaryCode.opacity"` theme color. For
         * example, `"editorUnnecessaryCode.opacity": "#000000c0"` will render the
         * code with 75% opacity. For high contrast themes, use the
         * `"editorUnnecessaryCode.border"` theme color to underline unnecessary code
         * instead of fading it out.
         */
        Unnecessary = 1,
    }

    /**
     * Represents a diagnostic, such as a compiler error or warning. Diagnostic objects
     * are only valid in the scope of a file.
     */
    export class Diagnostic {

        /**
         * The range to which this diagnostic applies.
         */
        range: Range;

        /**
         * The human-readable message.
         */
        message: string;

        /**
         * The severity, default is [error](#DiagnosticSeverity.Error).
         */
        severity: DiagnosticSeverity;

        /**
         * A human-readable string describing the source of this
         * diagnostic, e.g. 'typescript' or 'super lint'.
         */
        source?: string;

        /**
         * A code or identifier for this diagnostics. Will not be surfaced
         * to the user, but should be used for later processing, e.g. when
         * providing [code actions](#CodeActionContext).
         */
        code?: string | number;

        /**
         * An array of related diagnostic information, e.g. when symbol-names within
         * a scope collide all definitions can be marked via this property.
         */
        relatedInformation?: DiagnosticRelatedInformation[];

        /**
         * Additional metadata about the diagnostic.
         */
        tags?: DiagnosticTag[];

        /**
         * Creates a new diagnostic object.
         *
         * @param range The range to which this diagnostic applies.
         * @param message The human-readable message.
         * @param severity The severity, default is [error](#DiagnosticSeverity.Error).
         */
        constructor(range: Range, message: string, severity?: DiagnosticSeverity);
    }

    export interface DiagnosticCollection {

        /**
         * The name of this diagnostic collection, for instance `typescript`. Every diagnostic
         * from this collection will be associated with this name. Also, the task framework uses this
         * name when defining [problem matchers](https://code.visualstudio.com/docs/editor/tasks#_defining-a-problem-matcher).
         */
        readonly name: string;

        /**
         * Assign diagnostics for given resource. Will replace
         * existing diagnostics for that resource.
         *
         * @param uri A resource identifier.
         * @param diagnostics Array of diagnostics or `undefined`
         */
        set(uri: Uri, diagnostics: Diagnostic[] | undefined): void;

        /**
         * Replace all entries in this collection for given uris.
         *
         * Diagnostics of multiple tuples of the same uri will be merged, e.g
         * `[[file1, [d1]], [file1, [d2]]]` is equivalent to `[[file1, [d1, d2]]]`.
         * If a diagnostics item is `undefined` as in `[file1, undefined]`
         * all previous but not subsequent diagnostics are removed.
         *
         * @param entries An array of tuples, like `[[file1, [d1, d2]], [file2, [d3, d4, d5]]]`, or `undefined`.
         */
        set(entries: [Uri, Diagnostic[] | undefined][] | undefined): void;

        /**
         * Remove all diagnostics from this collection that belong
         * to the provided `uri`. The same as `#set(uri, undefined)`.
         *
         * @param uri A resource identifier.
         */
        delete(uri: Uri): void;

        /**
         * Remove all diagnostics from this collection. The same
         * as calling `#set(undefined)`;
         */
        clear(): void;

        /**
         * Iterate over each entry in this collection.
         *
         * @param callback Function to execute for each entry.
         * @param thisArg The `this` context used when invoking the handler function.
         */
        forEach(callback: (uri: Uri, diagnostics: Diagnostic[], collection: DiagnosticCollection) => any, thisArg?: any): void;

        /**
         * Get the diagnostics for a given resource. *Note* that you cannot
         * modify the diagnostics-array returned from this call.
         *
         * @param uri A resource identifier.
         * @returns An immutable array of [diagnostics](#Diagnostic) or `undefined`.
         */
        get(uri: Uri): Diagnostic[] | undefined;

        /**
         * Check if this collection contains diagnostics for a
         * given resource.
         *
         * @param uri A resource identifier.
         * @returns `true` if this collection has diagnostic for the given resource.
         */
        has(uri: Uri): boolean;

        /**
         * Dispose and free associated resources. Calls
         * [clear](#DiagnosticCollection.clear).
         */
        dispose(): void;
    }

    export class CodeAction {
        title: string;
        diagnostics?: Diagnostic[];
        edit?: WorkspaceEdit;
        command?: Command;
        kind?: CodeActionKind;
        constructor(title: string, kind?: CodeActionKind);
    }

    export interface CodeActionProvider {
        provideCodeActions(
            document: TextDocument,
            range: Range | Selection,
            context: CodeActionContext,
            token: CancellationToken | undefined
        ): ProviderResult<(Command | CodeAction)[]>;
    }

    export interface CodeActionProviderMetadata {
        readonly providedCodeActionKinds?: ReadonlyArray<CodeActionKind>;
    }

    export class CodeLens {
        /**
         * The range in which this code lens is valid. Should only span a single line.
         */
        range: Range;
        /**
         * The command this code lens represents.
         */
        command?: Command;
        /**
         * `true` when there is a command associated.
         */
        readonly isResolved: boolean;
        /**
         * Creates a new code lens object.
         *
         * @param range The range to which this code lens applies.
         * @param command The command associated to this code lens.
         */
        constructor(range: Range, command?: Command);
    }

    export interface CodeLensProvider<T extends CodeLens = CodeLens> {
        onDidChangeCodeLenses?: Event<void>;
        provideCodeLenses(document: TextDocument, token: CancellationToken): ProviderResult<T[]>;
        resolveCodeLens?(codeLens: T, token: CancellationToken): ProviderResult<T>;
    }

    /**
     * The document symbol provider interface defines the contract between extensions and
     * the [go to symbol](https://code.visualstudio.com/docs/editor/editingevolved#_go-to-symbol)-feature.
     */
    export interface DocumentSymbolProvider {

        /**
         * Provide symbol information for the given document.
         *
         * @param document The document in which the command was invoked.
         * @param token A cancellation token.
         * @return An array of document highlights or a thenable that resolves to such. The lack of a result can be
         * signaled by returning `undefined`, `null`, or an empty array.
         */
        provideDocumentSymbols(document: TextDocument, token: CancellationToken): ProviderResult<SymbolInformation[] | DocumentSymbol[]>;
    }

    /**
     * Represents programming constructs like variables, classes, interfaces etc. that appear in a document. Document
     * symbols can be hierarchical and they have two ranges: one that encloses its definition and one that points to
     * its most interesting range, e.g. the range of an identifier.
     */
    export class DocumentSymbol {

        /**
         * The name of this symbol.
         */
        name: string;

        /**
         * More detail for this symbol, e.g the signature of a function.
         */
        detail: string;

        /**
         * The kind of this symbol.
         */
        kind: SymbolKind;

        tags?: ReadonlyArray<SymbolTag>;

        /**
         * The range enclosing this symbol not including leading/trailing whitespace but everything else, e.g comments and code.
         */
        range: Range;

        /**
         * The range that should be selected and reveal when this symbol is being picked, e.g the name of a function.
         * Must be contained by the [`range`](#DocumentSymbol.range).
         */
        selectionRange: Range;

        /**
         * Children of this symbol, e.g. properties of a class.
         */
        children: DocumentSymbol[];

        /**
         * Creates a new document symbol.
         *
         * @param name The name of the symbol.
         * @param detail Details for the symbol.
         * @param kind The kind of the symbol.
         * @param range The full range of the symbol.
         * @param selectionRange The range that should be reveal.
         */
        constructor(name: string, detail: string, kind: SymbolKind, range: Range, selectionRange: Range);
    }

    /**
     * Represents information about programming constructs like variables, classes,
     * interfaces etc.
     */
    export class SymbolInformation {

        /**
         * The name of this symbol.
         */
        name: string;

        /**
         * The name of the symbol containing this symbol.
         */
        containerName: string;

        /**
         * The kind of this symbol.
         */
        kind: SymbolKind;

        tags?: ReadonlyArray<SymbolTag>;

        /**
         * The location of this symbol.
         */
        location: Location;

        /**
         * Creates a new symbol information object.
         *
         * @param name The name of the symbol.
         * @param kind The kind of the symbol.
         * @param containerName The name of the symbol containing the symbol.
         * @param location The location of the symbol.
         */
        constructor(name: string, kind: SymbolKind, containerName: string, location: Location);

        /**
         * ~~Creates a new symbol information object.~~
         *
         * @deprecated Please use the constructor taking a [location](#Location) object.
         *
         * @param name The name of the symbol.
         * @param kind The kind of the symbol.
         * @param range The range of the location of the symbol.
         * @param uri The resource of the location of symbol, defaults to the current document.
         * @param containerName The name of the symbol containing the symbol.
         */
        constructor(name: string, kind: SymbolKind, range: Range, uri?: Uri, containerName?: string);
    }

    export enum SymbolTag {
        Deprecated = 1
    }

    /**
     * A symbol kind.
     */
    export enum SymbolKind {
        File = 0,
        Module = 1,
        Namespace = 2,
        Package = 3,
        Class = 4,
        Method = 5,
        Property = 6,
        Field = 7,
        Constructor = 8,
        Enum = 9,
        Interface = 10,
        Function = 11,
        Variable = 12,
        Constant = 13,
        String = 14,
        Number = 15,
        Boolean = 16,
        Array = 17,
        Object = 18,
        Key = 19,
        Null = 20,
        EnumMember = 21,
        Struct = 22,
        Event = 23,
        Operator = 24,
        TypeParameter = 25
    }

    export class Hover {

        /**
         * The contents of this hover.
         */
        contents: MarkedString[];

        /**
         * The range to which this hover applies. When missing, the
         * editor will use the range at the current position or the
         * current position itself.
         */
        range?: Range;

        /**
         * Creates a new hover object.
         *
         * @param contents The contents of the hover.
         * @param range The range to which the hover applies.
         */
        constructor(contents: MarkedString | MarkedString[], range?: Range);
    }
    export interface HoverProvider {

        /**
         * Provide a hover for the given position and document. Multiple hovers at the same
         * position will be merged by the editor. A hover can have a range which defaults
         * to the word range at the position when omitted.
         *
         * @param document The document in which the command was invoked.
         * @param position The position at which the command was invoked.
         * @param token A cancellation token.
         * @return A hover or a thenable that resolves to such. The lack of a result can be
         * signaled by returning `undefined` or `null`.
         */
        provideHover(document: TextDocument, position: Position, token: CancellationToken | undefined): ProviderResult<Hover>;
    }

    export interface FileDeleteEvent {
        readonly files: ReadonlyArray<Uri>;
    }

    export interface FileCreateEvent {
        readonly files: ReadonlyArray<Uri>;
    }

    export interface FileRenameEvent {
        readonly files: ReadonlyArray<{ oldUri: Uri, newUri: Uri }>;
    }
    
    export interface TextDocument {
        readonly uri: Uri;
        readonly fileName: string;
        readonly isDirty: boolean;
        readonly isClosed: boolean;
        readonly version?: number;
        readonly languageId: string;
        save(): Promise<boolean>;
        readonly eol: EndOfLine;
        readonly lineCount: number;
        lineAt(line: number): TextLine;
        lineAt(position: Position): TextLine;
        offsetAt(position: Position): number;
        positionAt(offset: number): Position;
        getText(range?: Range): string;
        getWordRangeAtPosition(position: Position, regex?: RegExp): Range | undefined;
        validateRange(range: Range): Range;
        validatePosition(position: Position): Position;
    }
    export interface TextDocumentShowOptions {
        selection?: Range;
    }
    export interface TextDocumentChangeEvent {
        prevDocument: TextDocument;
        document: TextDocument;
        contentChanges: TextDocumentContentChangeEvent[];
    }
    export interface TextDocumentContentChangeEvent {
        range: Range;
        rangeOffset: number;
        rangeLength: number;
        text: string;
    }
    export interface FileSystemWatcher extends Disposable {
        ignoreCreateEvents: boolean;
        ignoreChangeEvents: boolean;
        ignoreDeleteEvents: boolean;
        onDidCreate: Event<Uri>;
        onDidChange: Event<Uri>;
        onDidDelete: Event<Uri>;
    }
    export interface TextDocumentContentProvider {
        onDidChange?: Event<Uri>;
        provideTextDocumentContent(uri: Uri, token: CancellationToken): ProviderResult<string>;
    }
    /**
     * Represents an incoming call, e.g. a caller of a method or constructor.
     */
    export class CallHierarchyIncomingCall {

        /**
         * The item that makes the call.
         */
        from: CallHierarchyItem;

        /**
         * The range at which at which the calls appears. This is relative to the caller
         * denoted by [`this.from`](#CallHierarchyIncomingCall.from).
         */
        fromRanges: Range[];

        /**
         * Create a new call object.
         *
         * @param item The item making the call.
         * @param fromRanges The ranges at which the calls appear.
         */
        constructor(item: CallHierarchyItem, fromRanges: Range[]);
    }

    /**
     * Represents an outgoing call, e.g. calling a getter from a method or a method from a constructor etc.
     */
    export class CallHierarchyOutgoingCall {

        /**
         * The item that is called.
         */
        to: CallHierarchyItem;

        /**
         * The range at which this item is called. This is the range relative to the caller, e.g the item
         * passed to [`provideCallHierarchyOutgoingCalls`](#CallHierarchyItemProvider.provideCallHierarchyOutgoingCalls)
         * and not [`this.to`](#CallHierarchyOutgoingCall.to).
         */
        fromRanges: Range[];

        /**
         * Create a new call object.
         *
         * @param item The item being called
         * @param fromRanges The ranges at which the calls appear.
         */
        constructor(item: CallHierarchyItem, fromRanges: Range[]);
    }
    /**
     * Represents programming constructs like functions or constructors in the context
     * of call hierarchy.
     */
    export class CallHierarchyItem {
        /**
         * The name of this item.
         */
        name: string;

        /**
         * The kind of this item.
         */
        kind: SymbolKind;

        /**
         * More detail for this item, e.g. the signature of a function.
         */
        detail?: string;

        /**
         * The resource identifier of this item.
         */
        uri: Uri;

        /**
         * The range enclosing this symbol not including leading/trailing whitespace but everything else, e.g. comments and code.
         */
        range: Range;

        /**
         * The range that should be selected and revealed when this symbol is being picked, e.g. the name of a function.
         * Must be contained by the [`range`](#CallHierarchyItem.range).
         */
        selectionRange: Range;

        /**
         * Creates a new call hierarchy item.
         */
        constructor(kind: SymbolKind, name: string, detail: string, uri: Uri, range: Range, selectionRange: Range);
    }
    export interface CallHierarchyProvider {
        prepareCallHierarchy(document: TextDocument, position: Position, token: CancellationToken): ProviderResult<CallHierarchyItem>;
        provideCallHierarchyIncomingCalls(item: CallHierarchyItem, token: CancellationToken): ProviderResult<CallHierarchyIncomingCall[]>;
        provideCallHierarchyOutgoingCalls(item: CallHierarchyItem, token: CancellationToken): ProviderResult<CallHierarchyOutgoingCall[]>;
    }
    /**
     * Information about where a symbol is defined.
     *
     * Provides additional metadata over normal [location](#Location) definitions, including the range of
     * the defining symbol
     */
    export interface DefinitionLink {
        /**
         * Span of the symbol being defined in the source file.
         *
         * Used as the underlined span for mouse definition hover. Defaults to the word range at
         * the definition position.
         */
        originSelectionRange?: Range;

        /**
         * The resource identifier of the definition.
         */
        targetUri: Uri;

        /**
         * The full range of the definition.
         *
         * For a class definition for example, this would be the entire body of the class definition.
         */
        targetRange: Range;

        /**
         * The span of the symbol definition.
         *
         * For a class definition, this would be the class name itself in the class definition.
         */
        targetSelectionRange?: Range;
    }

    /**
     * The definition of a symbol represented as one or many [locations](#Location).
     * For most programming languages there is only one location at which a symbol is
     * defined.
     */
    export type Definition = Location | Location[];
    export interface DefinitionProvider {
        provideDefinition(document: TextDocument, position: Position, token: CancellationToken | undefined): ProviderResult<Definition | DefinitionLink[]>;
    }
    export interface ImplementationProvider {
        provideImplementation(document: TextDocument, position: Position, token: CancellationToken): ProviderResult<Definition | DefinitionLink[]>;
    }

    export interface FormattingOptions {
        /**
         * Size of a tab in spaces.
         */
        tabSize: number;
        /**
         * Prefer spaces over tabs.
         */
        insertSpaces: boolean;
        /**
         * Signature for further properties.
         */
        [key: string]: boolean | number | string;
    }

    export class CodeActionKind {
        /**
         * Empty kind.
         */
        static readonly Empty: CodeActionKind;

        /**
         * Base kind for quickfix actions: `quickfix`.
         *
         * Quick fix actions address a problem in the code and are shown in the normal code action context menu.
         */
        static readonly QuickFix: CodeActionKind;

        /**
         * Base kind for refactoring actions: `refactor`
         *
         * Refactoring actions are shown in the refactoring context menu.
         */
        static readonly Refactor: CodeActionKind;

        /**
         * Base kind for refactoring extraction actions: `refactor.extract`
         *
         * Example extract actions:
         *
         * - Extract method
         * - Extract function
         * - Extract variable
         * - Extract interface from class
         * - ...
         */
        static readonly RefactorExtract: CodeActionKind;

        /**
         * Base kind for refactoring inline actions: `refactor.inline`
         *
         * Example inline actions:
         *
         * - Inline function
         * - Inline variable
         * - Inline constant
         * - ...
         */
        static readonly RefactorInline: CodeActionKind;

        /**
         * Base kind for refactoring rewrite actions: `refactor.rewrite`
         *
         * Example rewrite actions:
         *
         * - Convert JavaScript function to class
         * - Add or remove parameter
         * - Encapsulate field
         * - Make method static
         * - Move method to base class
         * - ...
         */
        static readonly RefactorRewrite: CodeActionKind;

        /**
         * Base kind for source actions: `source`
         *
         * Source code actions apply to the entire file and can be run on save
         * using `editor.codeActionsOnSave`. They also are shown in `source` context menu.
         */
        static readonly Source: CodeActionKind;

        /**
         * Base kind for an organize imports source action: `source.organizeImports`.
         */
        static readonly SourceOrganizeImports: CodeActionKind;

        constructor(value: string);

        /**
         * String value of the kind, e.g. `"refactor.extract.function"`.
         */
        readonly value: string;

        /**
         * Create a new kind by appending a more specific selector to the current kind.
         *
         * Does not modify the current kind.
         */
        append(parts: string): CodeActionKind;

        /**
         * Does this kind contain `other`?
         *
         * The kind `"refactor"` for example contains `"refactor.extract"` and ``"refactor.extract.function"`, but not `"unicorn.refactor.extract"` or `"refactory.extract"`
         *
         * @param other Kind to check.
         */
        contains(other: CodeActionKind): boolean;

        /**
         * Check if this code action kind intersects `other`.
         * The kind "refactor.extract" for example intersects refactor, "refactor.extract" and
         * `"refactor.extract.function", but not "unicorn.refactor.extract", or "refactor.extractAll".
         *
         * @param other Kind to check.
         */
        intersects(other: CodeActionKind): boolean;
    }

    export interface CodeActionContext {
        /**
         * An array of diagnostics.
         */
        readonly diagnostics: Diagnostic[];

        /**
         * Requested kind of actions to return.
         *
         * Actions not of this kind are filtered out before being shown by the lightbulb.
         */
        readonly only?: CodeActionKind;
    }

    /**
     * A workspace edit is a collection of textual and files changes for
     * multiple resources and documents.
     *
     * Use the [applyEdit](#workspace.applyEdit)-function to apply a workspace edit.
     */
    export class WorkspaceEdit {

        /**
         * The number of affected resources of textual or resource changes.
         */
        readonly size: number;

        /**
         * Replace the given range with given text for the given resource.
         *
         * @param uri A resource identifier.
         * @param range A range.
         * @param newText A string.
         */
        replace(uri: Uri, range: Range, newText: string): void;

        /**
         * Insert the given text at the given position.
         *
         * @param uri A resource identifier.
         * @param position A position.
         * @param newText A string.
         */
        insert(uri: Uri, position: Position, newText: string): void;

        /**
         * Delete the text at the given range.
         *
         * @param uri A resource identifier.
         * @param range A range.
         */
        delete(uri: Uri, range: Range): void;

        /**
         * Check if a text edit for a resource exists.
         *
         * @param uri A resource identifier.
         * @return `true` if the given resource will be touched by this edit.
         */
        has(uri: Uri): boolean;

        /**
         * Set (and replace) text edits for a resource.
         *
         * @param uri A resource identifier.
         * @param edits An array of text edits.
         */
        set(uri: Uri, edits: TextEdit[]): void;

        /**
         * Get the text edits for a resource.
         *
         * @param uri A resource identifier.
         * @return An array of text edits.
         */
        get(uri: Uri): TextEdit[];

        /**
         * Create a regular file.
         *
         * @param uri Uri of the new file..
         * @param options Defines if an existing file should be overwritten or be
         * ignored. When overwrite and ignoreIfExists are both set overwrite wins.
         */
        createFile(uri: Uri, options?: { overwrite?: boolean, ignoreIfExists?: boolean }): void;

        /**
         * Delete a file or folder.
         *
         * @param uri The uri of the file that is to be deleted.
         */
        deleteFile(uri: Uri, options?: { recursive?: boolean, ignoreIfNotExists?: boolean }): void;

        /**
         * Rename a file or folder.
         *
         * @param oldUri The existing file.
         * @param newUri The new location.
         * @param options Defines if existing files should be overwritten or be
         * ignored. When overwrite and ignoreIfExists are both set overwrite wins.
         */
        renameFile(oldUri: Uri, newUri: Uri, options?: { overwrite?: boolean, ignoreIfExists?: boolean }): void;

        /**
         * Get all text edits grouped by resource.
         *
         * @return A shallow copy of `[Uri, TextEdit[]]`-tuples.
         */
        entries(): [Uri, TextEdit[]][];
    }

    export interface DocumentFormattingEditProvider {
        provideDocumentFormattingEdits(
            document: TextDocument,
            options: FormattingOptions,
            token: CancellationToken | undefined
        ): ProviderResult<TextEdit[] | undefined>;
    }

    export interface DocumentRangeFormattingEditProvider {
        provideDocumentRangeFormattingEdits(
            document: TextDocument,
            range: Range,
            options: FormattingOptions,
            token: CancellationToken | undefined
        ): ProviderResult<TextEdit[] | undefined>;
    }

    export interface OnTypeFormattingEditProvider {
        provideOnTypeFormattingEdits(document: TextDocument,
            position: Position,
            ch: string,
            options: FormattingOptions,
            token: CancellationToken | undefined
        ): ProviderResult<TextEdit[] | undefined>;
    }

    export interface Command {

        command?: string;

        id: string;
        /**
         * The identifier of the actual command handler.
         */
        // command?: string;
        /**
        * Title of the command invocation, like "Add local varible 'foo'".
        */
        title: string;
        /**
          * A tooltip for for command, when represented in the UI.
          */
        tooltip?: string;
        /**
         * Arguments that the command handler should be
         * invoked with.
         */
        arguments?: any[];
    }
    export interface CommandDescription {
        id: string;
        label?: string;
        icon?: string;
        description?: string;
    }
    export interface QuickDiffProvider {
        provideOriginalResource?(uri: Uri, token: CancellationToken): ProviderResult<Uri>;
    }
    export interface SourceControlResourceThemableDecorations {
        readonly iconPath?: string | Uri;
    }
    export interface SourceControlResourceDecorations extends SourceControlResourceThemableDecorations {
        readonly strikeThrough?: boolean;
        readonly faded?: boolean;
        readonly tooltip?: string;
        readonly light?: SourceControlResourceThemableDecorations;
        readonly dark?: SourceControlResourceThemableDecorations;
    }
    export interface SourceControlConflictingResource {
        readonly command?: Command;
        readonly resourceUri: Uri;
    }
    export interface SourceControlResourceState {
        readonly resourceUri: Uri;
        readonly command?: Command;
        readonly decorations?: SourceControlResourceDecorations;
    }
    export interface SourceControlResourceGroup {
        readonly id: string;
        label: string;
        hideWhenEmpty?: boolean;
        resourceStates: SourceControlResourceState[];
        dispose(): void;
    }
    export interface SourceControl {
        readonly id: string;
        readonly label: string;
        readonly rootUri: Uri | undefined;
        quickDiffProvider?: QuickDiffProvider;
        createResourceGroup(id: string, label: string): SourceControlResourceGroup;
        conflictingResources: SourceControlConflictingResource[];
        statusBarCommands?: Command[];
        dispose(): void;
    }

    export interface WorkspaceFolder {
        /**
         * The associated uri for this workspace folder.
         *
         * *Note:* The [Uri](#Uri)-type was intentionally chosen such that future releases of the editor can support
         * workspace folders that are not stored on the local disk, e.g. `ftp://server/workspaces/foo`.
         */
        readonly uri: Uri;

        /**
         * The name of this workspace folder. Defaults to
         * the basename of its [uri-path](#Uri.path)
         */
        readonly name: string;

        /**
         * The ordinal number of this workspace folder.
         */
        readonly index: number;
    }

    export enum ShellQuoting {
        /**
         * Character escaping should be used. This for example
         * uses \ on bash and ` on PowerShell.
         */
        Escape = 1,

        /**
         * Strong string quoting should be used. This for example
         * uses " for Windows cmd and ' for bash and PowerShell.
         * Strong quoting treats arguments as literal strings.
         * Under PowerShell echo 'The value is $(2 * 3)' will
         * print `The value is $(2 * 3)`
         */
        Strong = 2,

        /**
         * Weak string quoting should be used. This for example
         * uses " for Windows cmd, bash and PowerShell. Weak quoting
         * still performs some kind of evaluation inside the quoted
         * string.  Under PowerShell echo "The value is $(2 * 3)"
         * will print `The value is 6`
         */
        Weak = 3
    }

    /** A string that will be quoted depending on the used shell. */
    export interface ShellQuotedString {
        /** The actual string value */
        value: string;

        /** The quoting style to use */
        quoting: ShellQuoting;
    }

    export interface ShellQuotingOptions {

        /**
         * The character used to do character escaping. If a string is provided only spaces
         * are escaped. If a `{ escapeChar, charsToEscape }` literal is provide all characters
         * in `charsToEscape` are escaped using the `escapeChar`.
         */
        escape?: string | {
            /** The escape character */
            escapeChar: string;

            /** The characters to escape */
            charsToEscape: string;
        };

        /** The character used for strong quoting. The string's length must be 1 */
        strong?: string;

        /** The character used for weak quoting. The string's length must be 1 */
        weak?: string;
    }

    export interface ShellExecutionOptions {

        /** The shell executable */
        executable?: string;

        /**
         * The arguments to be passed to the shell executable used to run the task. Most shells
         * require special arguments to execute a command. For  example `bash` requires the `-c`
         * argument to execute a command, `PowerShell` requires `-Command` and `cmd` requires both
         * `/d` and `/c`.
         */
        shellArgs?: string[];

        /** The shell quotes supported by this shell */
        shellQuoting?: ShellQuotingOptions;

        /**
         * The current working directory of the executed shell.
         * If omitted the tools current workspace root is used.
         */
        cwd?: string;

        /**
         * The additional environment of the executed shell. If omitted
         * the parent process' environment is used. If provided it is merged with
         * the parent process' environment.
         */
        env?: { [key: string]: string };
    }

    export class ShellExecution {
        /**
         * Creates a shell execution with a full command line.
         *
         * @param commandLine The command line to execute.
         * @param options Optional options for the started the shell.
         */
        constructor(commandLine: string, options?: ShellExecutionOptions);

        /**
         * Creates a shell execution with a command and arguments. For the real execution VS Code will
         * construct a command line from the command and the arguments. This is subject to interpretation
         * especially when it comes to quoting. If full control over the command line is needed please
         * use the constructor that creates a `ShellExecution` with the full command line.
         *
         * @param command The command to execute.
         * @param args The command arguments.
         * @param options Optional options for the started the shell.
         */
        constructor(command: string | ShellQuotedString, args: (string | ShellQuotedString)[], options?: ShellExecutionOptions);

        /**
         * The shell command line. Is `undefined` if created with a command and arguments.
         */
        commandLine?: string;

        /**
         * The shell options used when the command line is executed in a shell.
         * Defaults to undefined.
         */
        options?: ShellExecutionOptions;

        /**
         * The shell command. Is `undefined` if created with a full command line.
         */
        command?: string | ShellQuotedString;

        /**
         * The shell args. Is `undefined` if created with a full command line.
         */
        args?: (string | ShellQuotedString)[];
    }

    export interface ProcessExecutionOptions {
        /**
         * The current working directory of the executed program or shell.
         * If omitted the tools current workspace root is used.
         */
        cwd?: string;

        /**
         * The additional environment of the executed program or shell. If omitted
         * the parent process' environment is used. If provided it is merged with
         * the parent process' environment.
         */
        env?: { [key: string]: string };
    }

    export class ProcessExecution {

        /**
         * Creates a process execution.
         *
         * @param process The process to start.
         * @param options Optional options for the started process.
         */
        constructor(process: string, options?: ProcessExecutionOptions);

        /**
         * Creates a process execution.
         *
         * @param process The process to start.
         * @param args Arguments to be passed to the process.
         * @param options Optional options for the started process.
         */
        constructor(process: string, args: string[], options?: ProcessExecutionOptions);

        /** The process to be executed. */
        process: string;

        /** The arguments passed to the process. Defaults to an empty array. */
        args: string[];

        /**
         * The process options used when the process is executed.
         * Defaults to undefined.
         */
        options?: ProcessExecutionOptions;
    }

    export interface TaskDefinition {
        /**
         * The task definition describing the task provided by an extension.
         * Usually a task provider defines more properties to identify
         * a task. They need to be defined in the package.json of the
         * extension under the 'taskDefinitions' extension point. The npm
         * task definition for example looks like this
         * ```typescript
         * interface NpmTaskDefinition extends TaskDefinition {
         *     script: string;
         * }
         * ```
         *
         * Note that type identifier starting with a '$' are reserved for internal
         * usages and shouldn't be used by extensions.
         */
        readonly type: string;

        /** Additional attributes of a concrete task definition. */
        [name: string]: any;
    }

    export enum TaskScope {
        /** The task is a global task */
        Global = 1,

        /** The task is a workspace task */
        Workspace = 2
    }

    export class TaskGroup {

        /** The clean task group */
        static Clean: TaskGroup;

        /** The build task group */
        static Build: TaskGroup;

        /** The rebuild all task group */
        static Rebuild: TaskGroup;

        /** The test all task group */
        static Test: TaskGroup;

        private constructor(id: string, label: string);
    }

    /** Controls the behaviour of the terminal's visibility. */
    export enum TaskRevealKind {
        /** Always brings the terminal to front if the task is executed. */
        Always = 1,

        /**
         * Only brings the terminal to front if a problem is detected executing the task
         * (e.g. the task couldn't be started because).
         */
        Silent = 2,

        /** The terminal never comes to front when the task is executed. */
        Never = 3
    }

    /** Controls how the task channel is used between tasks */
    export enum TaskPanelKind {

        /** Shares a panel with other tasks. This is the default. */
        Shared = 1,

        /**
         * Uses a dedicated panel for this tasks. The panel is not
         * shared with other tasks.
         */
        Dedicated = 2,

        /** Creates a new panel whenever this task is executed. */
        New = 3
    }

    export interface TaskPresentationOptions {
        /**
         * Controls whether the task output is reveal in the user interface.
         * Defaults to `RevealKind.Always`.
         */
        reveal?: TaskRevealKind;

        /**
         * Controls whether the command associated with the task is echoed
         * in the user interface.
         */
        echo?: boolean;

        /** Controls whether the panel showing the task output is taking focus. */
        focus?: boolean;

        /**
         * Controls if the task panel is used for this task only (dedicated),
         * shared between tasks (shared) or if a new panel is created on
         * every task execution (new). Defaults to `TaskInstanceKind.Shared`
         */
        panel?: TaskPanelKind;

        /** Controls whether to show the "Terminal will be reused by tasks, press any key to close it" message. */
        showReuseMessage?: boolean;
    }

    export class Task {
        constructor(
            taskDefinition: TaskDefinition,
            scope: WorkspaceFolder | TaskScope.Global | TaskScope.Workspace,
            name: string,
            source?: string,
            execution?: ProcessExecution | ShellExecution,
            problemMatchers?: string | string[]);
        constructor(
            taskDefinition: TaskDefinition,
            name: string,
            source: string,
            execution?: ProcessExecution | ShellExecution,
            problemMatchers?: string | string[]);

        /** The task's name */
        name: string;

        /** The task's definition. */
        definition: TaskDefinition;

        /** The task's scope. */
        scope?: TaskScope.Global | TaskScope.Workspace | WorkspaceFolder;

        /** The task's execution engine */
        execution?: ProcessExecution | ShellExecution;

        /** Whether the task is a background task or not. */
        isBackground?: boolean;

        /**
         * A human-readable string describing the source of this
         * shell task, e.g. 'gulp' or 'npm'.
         */
        source?: string;

        /**
         * The task group this tasks belongs to. See TaskGroup
         * for a predefined set of available groups.
         * Defaults to undefined meaning that the task doesn't
         * belong to any special group.
         */
        group?: TaskGroup;

        /** The presentation options. Defaults to an empty literal. */
        presentationOptions?: TaskPresentationOptions;

        /**
         * The problem matchers attached to the task. Defaults to an empty
         * array.
         */
        problemMatchers?: string[];
    }

    export class Task2 extends Task {
        detail?: string;
    }

    export interface TaskProvider {
        provideTasks(token?: CancellationToken): ProviderResult<Task[]>;
        resolveTask(task: Task, token?: CancellationToken): ProviderResult<Task>;
    }

    /**
     * An object representing an executed Task. It can be used
     * to terminate a task.
     *
     * This interface is not intended to be implemented.
     */
    export interface TaskExecution {
        /**
         * The task that got started.
         */
        task: Task;

        /**
         * Terminates the task execution.
         */
        terminate(): void;
    }

    /**
     * An event signaling the start of a task execution.
     *
     * This interface is not intended to be implemented.
     */
    interface TaskStartEvent {
        /**
         * The task item representing the task that got started.
         */
        execution: TaskExecution;
    }

    /**
     * An event signaling the end of an executed task.
     *
     * This interface is not intended to be implemented.
     */
    interface TaskEndEvent {
        /**
         * The task item representing the task that finished.
         */
        execution: TaskExecution;
    }

    /**
     * An event signaling the start of a process execution
     * triggered through a task
     */
    export interface TaskProcessStartEvent {
        /**
         * The task execution for which the process got started.
         */
        execution: TaskExecution;

        /**
         * The underlying process id.
         */
        processId: number;
    }

    /**
     * An event signaling the end of a process execution
     * triggered through a task
     */
    export interface TaskProcessEndEvent {

        /**
         * The task execution for which the process got started.
         */
        execution: TaskExecution;

        /**
         * The process's exit code.
         */
        exitCode: number;
    }

    export interface TaskFilter {
        /**
         * The task version as used in the tasks.json file.
         * The string support the package.json semver notation.
         */
        version?: string;

        /**
         * The type of tasks to return.
         */
        type?: string;
    }


    /**
     * The configuration target
     */
    export enum ConfigurationTarget {
        /**
         * Global configuration
         */
        Global = 1,
        /**
         * Workspace configuration
         */
        Workspace = 2,
        /**
         * Workspace folder configuration
         */
        WorkspaceFolder = 3
    }

    /**
     * An event describing the change in Configuration
     */
    export interface ConfigurationChangeEvent {

        /**
         * Returns `true` if the given section for the given resource (if provided) is affected.
         *
         * @param section Configuration name, supports _dotted_ names.
         * @param resource A resource Uri.
         * @return `true` if the given section for the given resource (if provided) is affected.
         */
        affectsConfiguration(section: string, resource?: Uri): boolean;
    }

    export interface WorkspaceConfiguration {
        get<T>(section: string): T | undefined;
        get<T>(section: string, defaultValue: T): T;
        has(section: string): boolean;
        inspect<T>(section: string): { key: string; defaultValue?: T; globalValue?: T; workspaceValue?: T, projectValue?: T } | undefined;
        update(section: string, value: any, configurationTarget?: ConfigurationTarget | boolean): PromiseLike<void>;
        readonly [key: string]: any;
    }

    export interface DebugConfiguration {
        /**
         * The type of the debug session.
         */
        type: string;
        /**
         * The name of the debug session.
         */
        name: string;
        /**
         * The request type of the debug session.
         */
        request: string;
        /**
         * Additional debug type specific properties.
         */
        [key: string]: any;
    }

    export interface DebugSession {
        /**
         * The unique ID of this debug session.
         */
        readonly id: string;
        /**
         * The debug session's type from the [debug configuration](#DebugConfiguration).
         */
        readonly type: string;
        /**
         * The debug session's name from the [debug configuration](#DebugConfiguration).
         */
        readonly name: string;
        /**
         * The "resolved" [debug configuration](#DebugConfiguration) of this session.
         */
        readonly configuration: DebugConfiguration;
        /**
         * Send a custom request to the debug adapter.
         */
        customRequest(command: string, args?: any): PromiseLike<any>;

        stop?(): any;
    }

    export interface DebugSessionCustomEvent {
        /**
         * The [debug session](#DebugSession) for which the custom event was received.
         */
        session: DebugSession;
        /**
         * Type of event.
         */
        event: string;
        /**
         * Event specific information.
         */
        body?: any;
    }

    export interface DebugConfigurationProvider {
        provideDebugConfigurations?(folder: WorkspaceFolder | undefined, token?: CancellationToken): ProviderResult<DebugConfiguration[]>;
        resolveDebugConfiguration?(folder: WorkspaceFolder | undefined, debugConfiguration: DebugConfiguration, token?: CancellationToken): ProviderResult<DebugConfiguration>;
        resolveDebugConfigurationWithSubstitutedVariables?(folder: WorkspaceFolder | undefined, debugConfiguration: DebugConfiguration, token?: CancellationToken): ProviderResult<DebugConfiguration>;
    }

    export interface DebugAdapterTracker {
        /**
         * A session with the debug adapter is about to be started.
         */
        onWillStartSession?(): void;
        /**
         * The debug adapter is about to receive a Debug Adapter Protocol message from VS Code.
         */
        onWillReceiveMessage?(message: any): void;
        /**
         * The debug adapter has sent a Debug Adapter Protocol message to VS Code.
         */
        onDidSendMessage?(message: any): void;
        /**
         * The debug adapter session is about to be stopped.
         */
        onWillStopSession?(): void;
        /**
         * An error with the debug adapter has occurred.
         */
        onError?(error: Error): void;
        /**
         * The debug adapter has exited with the given exit code or signal.
         */
        onExit?(code: number | undefined, signal: string | undefined): void;
    }

    export interface DebugAdapterTrackerFactory {
        createDebugAdapterTracker(session: DebugSession): ProviderResult<DebugAdapterTracker>;
    }

    export class DebugAdapterExecutable {
        constructor(command: string, args?: string[], options?: DebugAdapterExecutableOptions);
        readonly command: string;
        readonly args: string[];
        readonly options?: DebugAdapterExecutableOptions;
    }

    export interface DebugAdapterExecutableOptions {
        env?: { [key: string]: string };
        cwd?: string;
    }

    export class DebugAdapterServer {
        /**
         * The port.
         */
        readonly port: number;
        /**
         * The host.
         */
        readonly host?: string;
        /**
         * Create a description for a debug adapter running as a socket based server.
         */
        constructor(port: number, host?: string);
    }

    export type DebugAdapterDescriptor = DebugAdapterExecutable | DebugAdapterServer;

    export interface DebugAdapterDescriptorFactory {
        createDebugAdapterDescriptor(session: DebugSession, executable: DebugAdapterExecutable | undefined): ProviderResult<DebugAdapterDescriptor>;
    }

    export interface DebugConsole {
        append(value: string): void;
        appendLine(value: string): void;
    }

    export interface BreakpointsChangeEvent {
        /**
         * Added breakpoints.
         */
        readonly added: Breakpoint[];
        /**
         * Removed breakpoints.
         */
        readonly removed: Breakpoint[];
        /**
         * Changed breakpoints.
         */
        readonly changed: Breakpoint[];
    }

    export class Breakpoint {
        /**
         * The unique ID of the breakpoint.
         */
        readonly id: string;
        /**
         * Is breakpoint enabled.
         */
        readonly enabled: boolean;
        /**
         * An optional expression for conditional breakpoints.
         */
        readonly condition?: string;
        /**
         * An optional expression that controls how many hits of the breakpoint are ignored.
         */
        readonly hitCondition?: string;
        /**
         * An optional message that gets logged when this breakpoint is hit. Embedded expressions within {} are interpolated by the debug adapter.
         */
        readonly logMessage?: string;

        protected constructor(enabled?: boolean, condition?: string, hitCondition?: string, logMessage?: string);
    }

    export class SourceBreakpoint extends Breakpoint {
        /**
         * The source and line position of this breakpoint.
         */
        readonly location: Location;

        /**
         * Create a new breakpoint for a source location.
         */
        constructor(location: Location, enabled?: boolean, condition?: string, hitCondition?: string, logMessage?: string);
    }

    export class FunctionBreakpoint extends Breakpoint {
        /**
         * The name of the function to which this breakpoint is attached.
         */
        readonly functionName: string;

        /**
         * Create a new function breakpoint.
         */
        constructor(functionName: string, enabled?: boolean, condition?: string, hitCondition?: string, logMessage?: string);
    }

    export type PreferenceType = 'string' | 'array' | 'number' | 'integer' | 'object' | 'boolean' | 'null';

    export interface PreferenceSchemaProperties {
        [name: string]: PreferenceItem;
    }

    export interface PreferenceItem {
        type?: PreferenceType | PreferenceType[];
        minimum?: number;
        default?: any;
        defaultValue?: any;
        enum?: string[];
        description?: string;
        markdownDescription?: string;
        overridable?: boolean;
    }

    /**
     * Represents the type of a setting.
     */
    export type SettingType = 'string' | 'array' | 'number' | 'integer' | 'object' | 'boolean' | 'null';

    /**
     * Represents the scope of a setting.
     */
    export enum SettingsScope {
        User = 'USER', // The setting applies to the user.
        Workspace = 'WORKSPACE', // The setting applies to the workspace.
        Project = 'PROJECT' // The setting applies to the project.
    }

    /**
     * Represents a setting.
     */
    export interface Setting {
        type: SettingType; // The type of the setting.
        description?: string; // The description of the setting.
        markdownDescription?: string; // The description of the setting in markdown format.
        minimum?: number; // The minimum value allowed for the setting.
        maximum?: number; // The maximum value allowed for the setting.
        default?: any; // The default value of the setting.
        defaultValue?: any; // The default value of the setting (alternative property name).
        enum?: string[]; // The allowed values for the setting.
        overridable?: boolean; // Indicates whether the setting can be overridden.
    }

    /**
     * Represents a settings change event.
     * 
     * @template T - The type of the settings.
     */
    export interface SettingsChangeEvent<T> {
        /**
         * The ID of the setting that has changed.
         */
        readonly settingId: keyof T;

        /**
         * The new value of the setting.
         */
        readonly newValue?: T[keyof T];

        /**
         * The old value of the setting.
         */
        readonly oldValue?: T[keyof T];
    }


    /**
     * Represents an event emitter for settings changes.
     * 
     * @template T - The type of the settings.
     */
    export interface SettingsEventEmitter<T> {
        /**
         * Event that is triggered when settings are changed.
         */
        readonly onSettingsChanged: Event<SettingsChangeEvent<T>>;

        /**
         * Promise that resolves when the settings are ready.
         */
        readonly ready: Promise<void>;
    }

    /**
     * Represents a setting retrieval interface.
     * 
     * @template T - The type of the settings.
     */
    export interface SettingRetrieval<T> {
        /**
         * Retrieves a setting value by its ID.
         * 
         * @param {K} settingId - The ID of the setting.
         * @param {T[K]} defaultValue - The default value to return if the setting is not found.
         * @returns {T[K]} - The value of the setting.
         */
        get<K extends keyof T>(settingId: K, defaultValue?: T[K]): T[K];
        /**
         * Converts the setting retrieval object to a JSON representation.
         * 
         * @returns {Object} - The JSON representation of the setting retrieval object.
         */
        toJSON(): {[name: string]: any};
    }

    /**
     * Represents a proxy object that provides access to settings.
     * 
     * @typeparam T - The type of the settings.
     */
    export type SettingsProxy<T> = Readonly<T> & Disposable & SettingsEventEmitter<T> & SettingRetrieval<T>;

    /**
     * Represents a change in a setting's data.
     */
    export interface SettingsDataChange {
        id: string; // The ID of the setting.
        type?: SettingType; // The type of the setting.
        newValue?: any; // The new value of the setting.
        oldValue?: any; // The old value of the setting.
        scope: SettingsScope; // The scope of the setting.
        uri?: string | Uri; // The URI of the setting.
    }

    /**
     * Represents a collection of changes in settings data.
     */
    export interface SettingsDataChanges {
        [id: string]: SettingsDataChange; // The changes in settings data, indexed by the setting ID.
    }

    export namespace settings {
        /**
         * Registers settings for a specific scope.
         * 
         * @param scope - The scope of the settings.
         * @param settings - An object containing the settings to register.
         * @returns A promise that resolves to a SettingsProxy object.
         */
        export function registerSettings<T>(scope: SettingsScope, settings: { [name: string]: Setting }): Promise<SettingsProxy<T>>;

        /**
         * Retrieves the value of a setting.
         * 
         * @param settingId - The ID of the setting to retrieve the value for.
         * @param scope - The scope of the setting. Optional. If not provided, the default scope will be used.
         * @param uri - The URI of the setting. Optional.
         * @returns The value of the setting.
         */
        export function getValue(settingId: string, scope?: SettingsScope, uri?: Uri): any;

        /**
         * Sets the value of a setting.
         * 
         * @param settingId - The ID of the setting to set the value for.
         * @param value - The value to set for the setting.
         * @param scope - The scope of the setting. Optional. If not provided, the default scope will be used.
         * @param uri - The URI of the setting. Optional.
         * @returns A promise that resolves when the setting value has been set.
         */
        export function setValue(settingId: string, value: any, scope?: SettingsScope, uri?: Uri): Promise<void>;

        /**
         * An event that is fired when the settings change.
         */
        export const onDidSettingsChanged: Event<SettingsDataChanges>;
    }


    export namespace debug {
        export let activeDebugSession: DebugSession | undefined;
        export let activeDebugConsole: DebugConsole;
        export let breakpoints: Breakpoint[];
        export const onDidChangeActiveDebugSession: Event<DebugSession | undefined>;
        export const onDidStartDebugSession: Event<DebugSession>;
        export const onDidReceiveDebugSessionCustomEvent: Event<DebugSessionCustomEvent>;
        export const onDidTerminateDebugSession: Event<DebugSession>;
        export const onDidChangeBreakpoints: Event<BreakpointsChangeEvent>;
        export function registerDebugAdapterDescriptorFactory(debugType: string, factory: DebugAdapterDescriptorFactory): Disposable;
        export function registerDebugConfigurationProvider(debugType: string, provider: DebugConfigurationProvider): Disposable;
        export function registerDebugAdapterTrackerFactory(debugType: string, factory: DebugAdapterTrackerFactory): Disposable;
        export function startDebugging(folder: WorkspaceFolder | undefined, nameOrConfiguration: string | DebugConfiguration, parentSessionOrOptions?: DebugSession| { parentSession: DebugSession }): PromiseLike<boolean>;
        export function addBreakpoints(breakpoints: Breakpoint[]): void;
        export function removeBreakpoints(breakpoints: Breakpoint[]): void;
    }

    export class ZCodeLanguageClient {
        readonly onDidLanguageClientStart: Event<void>;
        onDidLanguageClientStartEmitter: any;
        projectPath: string;
        start(): Promise<boolean>;
        ready: Promise<void>;
        initialized(): void;
        initialize(params: any): void;
        sendCustomRequest(method: string, params?: any[] | object): any;
        sendCustomNotification(method: string, params?: any[] | object): void;
        completion(params: any, cancellationToken?: any): any;
        hover(params: any): any;
        gotoDefinition(params: any): any;
        gotoImplementation(params: any): any;
        findReferences(params: any): any;
        documentSymbols(params: any): any;
        codeAction(params: any): any;
        prepareCallHierarchy(params: any): any;
        callHierarchyIncomingCalls(params: any): any;
        callHierarchyOutgoingCalls(params: any): any;
        documentFormatting(params: any): any;
        documentRangeFormatting(params: any): any;
        documentOntypeFormatting(params: any): any;
        documentSemantics(params: any): any;
        documentHighlights(params: any): any;
        onCustom(method: string, callback: (obj: object) => void): void;
        onPublishDiagnostics(callback: (params: any) => void): void;
        didOpenTextDocument(params: any): void;
        didChangeTextDocument(params: any): void;
        didSaveTextDocument(params: any): void;
    }
    export namespace ZCodeToLSPConvertor {
        export function toDidOpenTextDocumentParams(textDocument: TextDocument): any;
        export function toTextDocumentIdentifier(textDocument: TextDocument): any;
        export function toTextDocumentPositionParams(textDocument: TextDocument, position: Position): any;
        export function toTextDocumentContentChangeParams(document: TextDocument, contentChanges: TextDocumentContentChangeEvent[]): any;
        export function toTextDocumentFormattingParams(document: TextDocument, formattingOptions: FormattingOptions): any;
        export function toTextDocumentRangeFormattingParams(document: TextDocument, range: Range, formattingOptions: FormattingOptions): any;
        export function toTextDocumentOntypeFormattingParams(document: TextDocument, position: Position, ch: string, formattingOptions: FormattingOptions): any;
        export function toDocumentSymbolParams(document: TextDocument): any;
        export function toTextDocumentSaveParams(document: TextDocument): any;
        export function toCodeActionsParams(document: TextDocument, range: Range | Selection, context: CodeActionContext): any;
        export function toCallHierarchyItem(item: CallHierarchyItem): any;
        export function toCompletionItem(completions: CompletionItem): any[];
    }
    export namespace LSPToZCodeConvertor {
        export function toCompletionItems(completions: any): CompletionItem[];
        export function toTextEdits(textEdits: any[]): TextEdit[];
        export function toSymbolInformations(values: any[]): SymbolInformation[];
        export function toSymbolInformation(values: any): SymbolInformation;
        export function toDocumentSymbols(values: any[]): DocumentSymbol[];
        export function toDocumentSymbol(values: any): DocumentSymbol;
        export function toLocationResult(values: any): Definition | DefinitionLink[];
        export function toWorkspaceEdit(item: any): WorkspaceEdit | undefined;
        export function asCodeAction(codeAction: any): CodeAction | undefined;
        export function asHover(hover: any): any;
        export function asCallHierarchyItem(item: any): CallHierarchyItem;
    }
    export namespace extensions {
        export const list: any | undefined;
        export const onDidChange: Event<void>;
        export function getExtension(id: string): Promise<any>;
    }
    
    export interface VersionControlManagerProperties {
        label: string;
        type: string;
        location: string;
    }

    export interface VersionControlManager {
        id: string;
        type: string;
        label: string;
        location: string;
        updateCurrentBranch(branch: string): void;
        addFileState(type: string, label: string): void;
        updateFiles(type: string, files: VersionControlFile[]): void;
        updateConflicts(files: string[]): void;
        dispose(): void;
    }

    export interface VersionControlFile {
        path: string;
        command: {
            id: string,
            args: any[]
        };
    }

    export namespace versionControl {
        export const currentManager: VersionControlManager;
        export const onDidChangeSelectedManager: Event<VersionControlManager>;
        export function addVersionControlManager(properties: VersionControlManagerProperties): VersionControlManager;
    }

    export interface LanguageServerExecutable {
        'command': string;
        'args': any[];
        'options'?: {
            [key: string]: any;
        }
    }

    export interface LanguageServerOptions {
        processConfig?: LanguageServerExecutable;
    }

    export interface LanguageClientOptions {
        documentSelector: DocumentSelector;
        documentSyncOptions: GlobPattern;
        initializationOptions?: any;
        workspaceFolders: string[];
        multiClient?: boolean;
    }

    export interface LanguageServerConfiguration {
        id: string;
        label: string;
        serverConfig: LanguageServerOptions;
        clientConfig: LanguageClientOptions;
    }

    export interface LanguageClient {
        sendRequest(method: string, args: any): Promise<any>;
        sendNotification(method: string, args: any): void;
        onRequest(method: string, callback: (params: any) => any): void;
        onNotification(method: string, callback: (params: any) => any): void;
        onStopped: Event<void>;
        restart(): void;
        dispose(): void;
    }

    export namespace languages {
        export function registerLanguageServer(config: LanguageServerConfiguration): Promise<LanguageClient>;
        export function registerCodeLensProvider(selector: DocumentSelector, provider: CodeLensProvider): Disposable;
        export function registerCompletionItemProvider(selector: DocumentSelector, provider: CompletionItemProvider, ...triggerCharacters: string[]): Disposable;
        export function registerCodeActionsProvider(selector: DocumentSelector, provider: CodeActionProvider, metadata?: CodeActionProviderMetadata): Disposable;
        export function createDiagnosticCollection(name: string): any;
        export function registerDocumentSymbolProvider(selector: DocumentSelector, provider: DocumentSymbolProvider): Disposable;
        export function registerDefinitionProvider(selector: DocumentSelector, provider: DefinitionProvider): Disposable;
        export function registerImplementationProvider(selector: DocumentSelector, provider: ImplementationProvider): Disposable;
        export function registerReferenceProvider(selector: DocumentSelector, provider: ReferenceProvider): Disposable;
        export function registerHoverProvider(selector: DocumentSelector, provider: HoverProvider): Disposable;
        export function registerCallHierarchyProvider(selector: DocumentSelector, provider: CallHierarchyProvider): Disposable;
        export function registerDocumentFormattingEditProvider(selector: DocumentSelector, provider: DocumentFormattingEditProvider): Disposable;
        export function registerDocumentRangeFormattingEditProvider(selector: DocumentSelector, provider: DocumentRangeFormattingEditProvider): Disposable;
        export function registerOnTypeFormattingEditProvider(selector: DocumentSelector, provider: OnTypeFormattingEditProvider, firstTriggerCharacter: string, ...moreTriggerCharacter: string[]): Disposable;
        export function registerDocumentSemanticTokensProvider(selector: DocumentSelector, provider: DocumentSemanticTokensProvider, legend: SemanticTokensLegend): Disposable;
        export function registerDocumentRangeSemanticTokensProvider(selector: DocumentSelector, provider: DocumentRangeSemanticTokensProvider, legend: SemanticTokensLegend): Disposable;
        export function registerDocumentHighlightProvider(selector: DocumentSelector, provider: DocumentHighlightProvider): Disposable;
    }
    export namespace window {
        export function showInformationMessage(message: string): void;
        export function showSuccessMessage(message: string): void;
        export function showProgressLoading(message?: string): Disposable;
        export function createProgressBar(message: string, mode: string): any;
        export function registerMenus(location: string, menus: any[]): Disposable;
        export const activeTextEditor: TextEditor;
        export const visibleTextEditors: TextEditor[];
        export const onDidChangeVisibleTextEditors: Event<TextEditor[]>;
        export function createTextEditorDecorationType(options: DecorationRenderOptions): TextEditorDecorationType;
        export function showWarningMessage(message: string): void;
        export function showErrorMessage(message: string): void;
        export function showAlertDialog(options: any): any;
        export function showTextDocument(document: TextDocument | Uri, options?: TextDocumentShowOptions): any;
        export function setStatusBarMessage(text: string, arg?: number | PromiseLike<any>): Disposable;
        export function createStatusBarItem(alignment?: StatusBarAlignment, priority?: number): StatusBarItem;
        export function resolveStaticResource(location: string): Uri;
    }

    export interface Logger {
        log(message: string): void;
        show(): void;
        dispose(): void;
    }

    export interface MenuItem {
        id: string;
        label: string;
        command?: string;
        icon?: string;
        group?: string;
        when?: string;
        subMenus?: MenuItem[];
    }

    export interface TabConfig {
        id: string;
        label: string;
        icon: string;
    }
    
    export interface PanelOptions {
        id: string;
        label: string;
        icon: string;
        position?: 'left' | 'right' | 'bottom';
    }

    export interface TreeNode {
        id: string;
        label: string;
        icon?: string;
        tooltip?: string;
        hasChildren?: boolean;
        contextValue?: string;
        command?: Command;
        children?: TreeNode[];
        data?: any;
    }

    export interface TreeViewPanel {
        addChildren(nodes: TreeNode[], parentNodeId?: string): void;
        clearChildren(parentNodeId: string): void;
        refreshNode(nodeId: string): void;
        removeNode(nodeId: string): void;
        expandNode(nodeId: string): void;
        changeActiveNode(nodeId: string, options?: {reveal: boolean}): void;
        clearTree(): void;
        dispose(): void;
    }

    export interface TreeViewDataProvider {
        getChildren(parentId: string): ProviderResult<TreeNode[]>;
    }

    export enum FormInputType {
        TEXT_FIELD = 'TEXT_FIELD', 
        TEXT_AREA = 'TEXT_AREA',
        CHECK_BOX = 'CHECK_BOX', 
        LIST = 'LIST',
        FILE_EXPLORER = 'FILE_EXPLORER',
        FILE_UPLOAD = 'FILE_UPLOAD'
    }

    export type FormInputValueType = string | number | boolean | object;

    export enum FormActionType {
        SUBMIT = 'SUBMIT',
        SECONDARY = 'SECONDARY',
        CANCEL = 'CANCEL'
    }

    interface BaseInputConfig {
        id: string;
        type: FormInputType,
        label: string;
        validation?: (value: any) => string | Promise<string>;
    }

    export interface TextFieldConfig extends BaseInputConfig {
        value: string;
        focussed?: boolean;
        prompt?: string;
        placeHolder?: string;
        password?: boolean;
        disabled?: boolean;
    }

    export interface TextAreaConfig extends BaseInputConfig {
        label: string;
        value: string;
        focussed?: boolean;
        prompt?: string;
        maxLength?: number;
        disabled?: boolean;
    }

    export interface CheckBoxConfig extends BaseInputConfig {
        label: string;
        value: boolean;
        prompt?: string;
    }

    export interface ListFieldConfig extends BaseInputConfig {
        label: string;
        value: string;
        values: {id: string, label: string}[];
    }

    export interface FileExplorerConfig extends BaseInputConfig {
        label: string;
        value: string;
        allowFiles?: boolean;
        allowFolders?: boolean;
    }

    export type FormInputConfig = TextFieldConfig | TextAreaConfig | CheckBoxConfig | ListFieldConfig | FileExplorerConfig;

    export interface FormActionOptions {
        id: string | number;
        label: string;
        type: FormActionType;
        action: (args: any[]) => any;
    }

    export interface FormDialogConfig {
        title: string;
        description?: string;
        inputs: FormInputConfig[];
        actions: FormActionOptions[];
    }

    export interface FormDialog {
        show(): void;
        hide(): void;
        dispose(): void;
        updateConfig(config: FormDialogConfig): void;
        updateInputOption(id: string, property: string, value: FormInputValueType): void;
        updateInputOptions(options: { id: string; property: string; value: FormInputValueType; }[]): void;
    }

    export interface AlertActionConfig {
        id: string;
        label: string;
        type: FormActionType;
    }

    export enum MessageType {
        INFO = 'INFO',
        SUCCESS = 'SUCCESS',
        WARNING = 'WARNING',
        ERROR = 'ERROR'
    }

    export interface AlertDialogConfig {
        title: string;
        message: string;
        type: MessageType;
        actions: AlertActionConfig[];
    }

    export interface WebviewPanel {
        setHtml(html: string): void;
        sendMessage(message: any): void;
        onMessage: Event<string>;
    }

    export namespace workbench {
        export const FormInputType: FormInputType;
        export function showInformationMessage(message: string): void;
        export function showSuccessMessage(message: string): void;
        export function showWarningMessage(message: string): void;
        export function showErrorMessage(message: string): void;
        export function showProgressLoading(message?: string): Disposable;
        export function createProgressBar(message: string, mode: string): any;
      	export function registerMenus(location: string, menus: MenuItem[]): Disposable;
        export function createLogChannel(title: string): Logger;
        export function createTreeviewPanel(panelOptions: PanelOptions, provider: TreeViewDataProvider): TreeViewPanel;
        export function createWebviewPanel(config?: PanelOptions, webviewOptions?: any): WebviewPanel;
        export function createWebviewTab(config?: TabConfig, webviewOptions?: any): WebviewPanel;
        export function createFormDialog(config: FormDialogConfig): FormDialog;
        export function showAlertDialog(options: AlertDialogConfig): any;
        export function resolveStaticResource(location: string): Uri;
    }
    export namespace commands {
        export function registerCommand(command: CommandDescription | string, handler?: (...args: any[]) => any, thisArg?: any): Disposable;
        export function registerHandler(commandId: string, handler: (...args: any[]) => any, thisArg?: any): void;
        export function executeCommand<T>(commandId: string, ...args: any[]): PromiseLike<T | undefined>;
    }
    export namespace preferences {
        export function registerPreferences(scope: string, preferences: any): Disposable;
        export function getPreference(section?: string, resource?: Uri | null): WorkspaceConfiguration;
        export const onDidPreferenceChanged: Event<ConfigurationChangeEvent>;
    }
    export namespace workspace {
        export const rootPath: string | undefined;
        export const projects: Uri[];
        export const onDidProjectAdded: Event<Uri>;
        export const onDidProjectRemoved: Event<Uri>;
        export function openTextDocument(uriData: string | Uri): Promise<any>;
        export function applyEdit(edit: WorkspaceEdit): PromiseLike<boolean>;
        export function registerTextDocumentContentProvider(scheme: string, provider: TextDocumentContentProvider): Disposable;
        export const onDidOpenTextDocument: Event<TextDocument>;
        export const onDidChangeTextDocument: Event<TextDocumentChangeEvent>;
        export const onDidSaveTextDocument: Event<TextDocument>;
        export const onDidCreateFiles: Event<FileCreateEvent>;
        export const onDidDeleteFiles: Event<FileCreateEvent>;
        export function createFileSystemWatcher(
            globPattern: GlobPattern,
            ignoreCreateEvents?: boolean,
            ignoreChangeEvents?: boolean,
            ignoreDeleteEvents?: boolean
        ): FileSystemWatcher;
        export function getConfiguration(section?: string, resource?: Uri | null): WorkspaceConfiguration;
        export const onDidChangeConfiguration: Event<ConfigurationChangeEvent>;
    }
    export namespace tasks {
        export function registerTaskProvider(type: string, provider: TaskProvider): Disposable;
        export function fetchTasks(filter?: TaskFilter): PromiseLike<Task[]>;
        export function executeTask(task: Task): PromiseLike<TaskExecution>;
        export const taskExecutions: ReadonlyArray<TaskExecution>;
        export const onDidStartTask: Event<TaskStartEvent>;
        export const onDidEndTask: Event<TaskEndEvent>;
        export const onDidStartTaskProcess: Event<TaskProcessStartEvent>;
        export const onDidEndTaskProcess: Event<TaskProcessEndEvent>;
    }
    export class ZCodeLanguageServer {
        constructor(id: string, options: any);

    }
}